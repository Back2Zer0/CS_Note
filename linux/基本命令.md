# Linux 基本





## 系统分区

FHS（Filesystem Hierarchy Standard）—— **文件系统层次化标准**。

> Filesystem Hierarchy Standard（文件系统层次化标准）的缩写，多数Linux版本采用这种文件组织形式，类似于Windows操作系统中c盘的文件目录，FHS采用树形结构组织文件。FHS定义了系统中每个区域的用途、所需要的最小构成的文件和目录，同时还给出了例外处理与矛盾处理。
>
> —— 百度百科



| 符号 | 解释           |
| :--- | :------------- |
| `~`  | 用户主目录     |
| `-`  | 上一次所在目录 |
| `.`  | 当前目录       |
| `..` | 上级目录       |



Linux与Windows一样，它的主分区和拓展分区加起来不能超过四个，而且**拓展分区不能放入数据文件且不能格式化**，最多一个拓展分区。拓展分区里放的**逻辑分区可以放数据和格式化。**

**Linux 硬件全为文件** 这一点与Windows不一样。

下面介绍一些Linux的主要硬件文件名已经存放路径：

- IDE硬盘 /dev/hd[a-d]
- SCSI/SATA/USB硬盘 /dev/sd[a-p]
- 光驱 /dev/cdrom或/dev/sr0
- 软盘 /dev/fd[0-1]
- 打印机（25针） /dev/lp[0-2]
- 打印机（USB） /dev/usb/lp[0-15]
- 鼠标 /dev/mouse

==分区==：把大硬盘分为小的逻辑分区
==格式化==：写入文件系统
==分区设备文件名==：给每个分区定义设备文件名
==挂载==：给每个分区分配挂载点

> **注意：**
>
> 1. 根分区 “/ ” 以下的子分区可以单独使用硬盘
> 2. 在虚拟机安装中 swap 的大小为内存的两倍但是超过2G没有意义，建议1000MB合适
> 3. /boot路径是为了让Linux系统可以顺利运行 里面最好不要存放数据 在虚拟机安装中分配200M左右大小就可以了
>    

## 系统管理

- 使用分号 `;` 分隔和执行多条命令
- 使用反斜线 `\` 多行输入
- 执行 `exit` 或 `ctrl d`（表示EOF），退出当前 shell
- **ls** 参数：

  - -a 所有文件
  - -l 详细信息
  - -h 文件大小可读
  - -F 类型指示
  - -d 仅查看当前目录的信息
  - -S 按文件大小排序
  - -t 按修改时间排序
  - -r 倒序

---

**查看 Linux 内核版本**

```shell
uname -r
uname -n
cat /proc/version
```

> 5.8.0-44-generic
>
> 主版本号.次版本号.发布版本-修改版本

**系统的运行级别：**

runlevel 查询系统运行级别
logout 退出登陆命令

共有六个级别：

init 0-6
0：关机
1：单用户 进入选项菜单 只有root用户登陆进去 相当于Windows安全模式F8，只不过没有图形界面
2：不完全多用户，不含NFS服务，没有图形界面 NFS网络文件系统，Linux之间文件传输共享方式，除了NFS服务，和3一样。
3：完全多用户，没有图形界面
4：未分配，没有图形界面
5：图形界面
6：重启

> 注意：在服务器中一定要在操作完成之后退出登陆，否则其他人会直接进入你的服务器，造成非常大的损失。最基本的安全意识一定要有！！！

**日期**

```shell
date [-s] <date>
```

**内存**

```shell
free -h
```

**进程**

```shell
ps [-u]
```

 **查询 PID**

```shell
pidof <ps>
```

>在linux系统的目录/var/run下面一般我们都会看到很多的*.pid文件。而且往往新安装的程序在运行后也会在/var/run目录下面产生自己的pid文件。那么这些pid文件有什么作用呢？它的内容又是什么呢？ 
>
>PID全称是Process Identification。
>
>PID是进程的代号，每个进程有唯一的PID编号。它是进程运行时系统随机分配的，不代表专门的进程。
>
>在运行时PID是不会改变标识符的，但是你终止程序后再运行PID标识符就会被系统回收，就可能会被继续分配给新运行的程序。
>
>范围是1~32768。
>
>1.  pid文件的内容：pid文件为文本文件，内容只有一行, 记录了该进程的ID。
>2. pid文件的作用：防止进程启动多个副本。只有获得pid文件(固定路径固定文件名)写入权限(F_WRLCK)的进程才能正常启动并把自身的PID写入该文件中。其它同一个程序的多余进程则自动退出。 

**发送信号**

```shell
kill [-信号声明 | -信号编号] <pid>

kill -l # 列出所有信号

killall # 结束一个程序的所有进程
```

 **命令别名**

```shell
alias <cmd>=<cmd>
```

> cmd：command

**输入历史**

```shell
history # 查看历史命令和编号

!<编号> # 执行编号指定的历史命令
```

**主机名**

```shell
hostname [set-hostname] <nm>
```



## 软硬链接

- 软链接：
  软链接的作用和Windows中的快捷方式是差不多的。他只不过是指向源文件安装路径的符号链接，所以大小也很小 。

  它的文件类型是lrwxrwxrwx 看似三种用户都可以拥有所有权限。其实，真正拥有的权限是源文件所决定的权限 ，所以这中显示也是软链接的一大特征之一。

  ```bash
  ln -s [原文件] [目标文件] 创建软链接
  ```

  > 这里的源文件路径一定要写成**绝对路径** ，否则链接不到。

- 硬链接：
  硬链接就是把源文件拷贝到目标位置，而**他与cp -p 最大的一点区别就是他可以同步更新。**

  源文件有变化 硬链接文件也会同时发生变化，但是如果源文件丢失或者被删除，硬链接也并不会消失。

  > 这里不同环境结果不一样。
  >
  > 我的Ubuntu软连接文件也不会随着源文件丢失而丢失。只是无法访问而已。

  可以通过i节点来区分，源文件和硬链接文件的i节点是一样的，所以他们会同步更新，但是他不能跨分区放置硬链接比如：/分区 硬链接 不能放到/boot 分区 ，而且不能对目录使用。

  ```bash
  ln [原文件] [目标文件] 创建硬链接
  ```



## 权限处理

###  权限表示

```bash
ls -l
```

>total 200k 
>
>文件权限   权限计数  所有者 所属组  文件大小 最后修改时间   文件名
>
>drwxr-x--- 16 fancyzzz fancyzzz 4.0k 7月11 14:26
>
>...

一个文件10个符号位 ： -rwx rwx rwx



**第一个符号位：**

| d    | 目录     |
| ---- | -------- |
| l    | 软连接   |
| b    | 块设备   |
| c    | 字符设备 |
| s    | socket   |
| p    | 管道     |
| -    | 普通文件 |

**后九位：**

每三位一组，分别对应 User  Group  Other：

- r：读权限
- w: 写权限
- x:  执行权限





### 修改权限

#### 1.复制权限设定：

| 命令                           | 效果                                                       |
| ------------------------------ | ---------------------------------------------------------- |
| chmod --reference=dir1 dir2    | 复制dir1目录的权限到dir2上                                 |
| chmod -R --reference=dir1 dir2 | 复制dir1目录的权限到dir2及dir2中的子文件上 -R 代表递归操作 |

#### 2.字符方式设定：

```bash
 chmod [{u,g,o,a}{+,-,=}{r,w,x}] [文件或者目录] 
```

u ：所有者

g ：所属组 

o ：其他人 

a ：所有用户 

| 命令                                            | 效果                                   |
| ----------------------------------------------- | -------------------------------------- |
| chmod （a;u;g;o) ( +;-;=)(r;w;x) 文件名或目录名 | 用字符方式设定文件或目录权限           |
| chmod -R（a;u;g;o) ( +;-;=)(r;w;x) 目录名       | 用字符方式设定目录以及该目录中文件权限 |

>例如：chomd g+x,o+r /tmp/testfile 是把testfile文件的所有组增加执行权限，其他人增加读权限 
>
>chomd a=rwx /tmp/testfile    是给 testfile文件的所有用户增加读写执行权限 

#### 3.数字方式设定权限：

权限的布尔表示方式：用三位二进制数表示八种不同情况的权限，然后转化为十进制数，并用三位十进制数，表示三个不同身份的权限信息，用数字方式设定对比字符方式设定更具有便捷，准确，不容易出错的特点：

```bash
chmod -R [rwx的和,rwx的和,rwx的和]] [文件或者目录]
```

- 首先需要知道 r=4 w=2 x=1
  例如：rwxrw-r- - 它的权限位数字表示就是 764
  
- 具体算法：
  r+w+x=4+2+1=7
  r+w=4+2+0=6
  r=4+0+0=4
  
- -R：
  
  ```bash
  chmod -R [rwx的和,rwx的和,rwx的和]] [文件或者目录]
  ```
  
  这条命令与mkdir -p递归创建目录一样 这个命令把一个目录下的所有子目录的操作权限全部修改为同样的
  

> 我们仍需注意在文件与目录中的不同权限，他们具体可以实施的操作是什么。这一点非常重要，有许多人到现在也不太清楚，认为对文件有写权限就可以删除文件。这一点是非常错误的。

|  代表字符|    权限  |  对文件的含义   |对目录的含义|
|---|---|---|---|
|r|读权限|可以查看文件内容 可以cat/more/head/tail/less|可以列出目录中的内容 可以ls|
|w|写权限|可以修改文件内容 可以vim|可以在目录中创建，删除文件；可以touch/mkdir/rmdir/rm|
|x	|执行权限	|可以执行文件 可以script(脚本) command(命令)	|可以进入目录 可以cd|



## 文件处理

- cat [文件名] 显示文件内容 只适合短的文件内容
  cat -n [文件名] 显示行号 给文件内容的每一行标号
  cat -A [文件名] 显示隐藏字符
  tac [文件名] 逆序显示文件内容 倒着来 不支持-n
  
- ```shell
  more [文件名] 
  ```

  一页一页显示文件内容 适合长的文件内容 **空格或者f 翻页 回车（Enter）一行一行翻，换行 q或者Q ，退出**

- ```bash
  less [文件名] 
  ```
  
  一页一页显示文件内容，只不过这条命令可以往回翻页，查看翻过的文件内容 page up向上翻页，↑箭头向上翻一行
  **其他操作和more命令一样 在less命令中 可以按/+需要查找文件内容的关键字查询内容，高亮内容即为含有关键字的内容，按n（表示next）可以查看下一个含有关键字的内容**
  
- head [文件名] 显示文件最前几行 具体几行加n head -n 行数 [文件名] 没有指定 默认10行

- tail [文件名] 显示文件最后几行 具体几行加n tail -n 行数 [文件名] 没有指定 默认10行 tail -f 动态显示文件末尾内容
  
- 移动：
  
  ```shell
  mv {src} {target}
  ```
  
- 重命名：
  
  ```shell
  mv {old} {new}
  ```

## 目录处理

（目录也算文件哦）

- 创建

mkdir 创建目录 在/tmp/目录下创建临时文件 只能创建/tmp/***** 二级目录
mkdir -p 可以递归创建 在没有一级目录的情况下新创建二级目录
pwd 显示当前所在路径

- 跳级

cd - 上一次的目录

cd ~ 返回家目录

cd . . 返回上一级目录(两个点连着）
rmdir 删除空目录 只能删除没有文件的空目录 （不经常使用）



## 增删改查

- touch [文件名] 在当前目录下创建空文件
  touch[绝对路径+文件名]。 指明绝对路径，在绝对路径处创建文件
  **“Program files” 加双引号创建带空格的文件名 不推荐使用 以后的查询，操作都需要用到 除了代表根分区的/ 以外 其他符号都可以**
- 复制

cp 复制文件 cp [原文件路径] [需要复制到的路径]
cp -r 复制目录
cp -p 保留原文件属性复制目录 比如保留创建时间 日志文件的复制需要用到
cp -rp 复制目录并且保留原文件属性
mv 剪切 改名（在同一个目录下为改名）

- 删除

rm 删除文件
rm -f 强制删除 不再询问
rm -r 删除目录 一般是rm -rf 连着用
control+C退出选项

>注意：
>rm -rf 使用时一定要谨慎 切记 ！！！
>使用时一定要谨慎 切记 ！！！
>使用时一定要谨慎 切记 ！！！
>rm -rf /* 系统直接全部被删除！！！

使用通配符时需要转义，例如`*.txt`应写成`\*.txt`。 

查找

1. 文件搜索命令==find==

   - find [搜索范围] [匹配条件] 

     ==通配符查询==

   - find [搜索范围] -name [关键字]

     > 在特定路径下搜索文件名作为关键字的文件或者目录

   - find [搜索范围] -name [关键字]*

     > 这样为带有关键字开头的任何文件都可以被搜索出来

   - find [搜索范围] -name * [关键字]*

     > 这样为带有关键字的任何文件都可以被搜索出来

   - find [搜索范围] -name [关键字]???

     > 这样搜索的是关键字后带三个字符的 几个问号为几个字符

     ==其他属性查询==

   - find [搜索范围] -iname [关键字] 不区分大小写搜索

     > 注意：不能在服务区高峰时候使用查找命令。太占内存资源，搜索的范围路径越小越好，搜索条件越精准越好

     

     ==所属者查询==

   - find [搜索范围] -user [所有者名] 

     > 根据所有者查找

   - find [搜索范围] -group [所属组名] 

     > 根据所属组查找

     ==根据时间查询==

   - find [搜索范围] -amin [时间] 

     > 查找时间以内被访问过的文件和目录 a：access

   - find [搜索范围] -cmin [时间] 

     > 查找时间以内被修改过属性的文件和目录 c：change

   - find [搜索范围] -mmin [时间] 

     > 查找时间以内被修改过内容的文件和目录 m：modift

     > +：超过多长时间 -：多长时间以内

     

     ==根据数据大小查询==

   - find [搜索范围] -size [数据块] 根据文件大小查找

     > 数据块前面加+表示查找大于这个大小的文件，-表示查找小于这个大小的文件，不加表示查找等于这个大小的文件(一般不常用
     > 1个数据块=512字节=0.5K
     > size后接的数据只能为数据块 需要换算，比如需要查找大于100MB的文件
     > 100MB=102400KB=204800
     > find /etc -size +204800
     > 数据块为Linux存储文件最小单位

   - find [搜索范围] -size [数据块] -a -size [数据块]

     > -a：两个条件同时满足
     > -o：两个条件满足任意一个即可
     > find /etc -size +163840 -a -size -204800
     > 在/etc下查找大于80MB小于100MB的文件

     ==查找特定类型==

   - find [搜索范围] -name [关键字] -a -type f

     > 在特定路径下搜索文件名作为关键字的文件
     > -type 根据不同类型查找
     > f：文件
     > d：目录
     > l：软链接

   - find [搜索范围] -name [关键字] -exec ls -l {} \ ;

     > 查找到文件之后并且对其进行查看ls操作。
     > -exec：查找到文件之后并且对其进行各种操作 {} \ ;不能丢
     > -ok：用于询问确认 一般在删除操作的时候使用，比如：

   - find -user **user_name** -ok rm {} \ ;

     > 删除**user_name**用户的文件 他会挨个询问你是不是确定删除

   - find [搜索范围] -inum [i 节点值]

     > 根据 i 节点查询

   - find /etc -inum 12345 -exec rm {} \ ;

     > 删除这个i节点文件 非常方便。也可以用来查询一个文件的硬链接

   - find /etc inum 12345 -exec ls -l {} \ ;

     > 因为硬链接和文件肯定在同一个分区，并且i节点一样





2. 文件搜索命令==locate==

   - locate [文件名]

     > 在文件资料库中查找 速度更快

     locate -i 不区分大小写查找

     updatedb 更新文件资料库 因为locate并不是实时的

     > (如果存放的文件在/tmp 临时文件存放处下面 locate就找不到，文件资料库不存储临时文件内容)

   - which 查找命令存放位置，可以看到命令可以使用的使用者是谁，也可以查看命令别名 which rm 会显示 alias rm='rm -i’

   > 我们所使用的rm只不过是别名 不是真正的rm命令，其实是rm -i命令，所以才会询问是否真的删除，真正的rm是不会询问的，比如：
   > /bin/rm /tmp/yangyang 文件直接删除不会询问是否删除 相当于加了 -f

   - whereis 也可以找到命令的绝对路径，还可以找到查询命令的帮助信息文档所在位置

   - grep 在文件内查询字符串或者关键字列出来
     grep -i 不区分大小写查找
     grep -v 排除指定字符串

     > 比如： grep -v ^# /etc/inittab
     > 查找排除#开头的注释行文件信息
     > ^代表行首  ,  文件中#开头的行 为配置文件信息,脚本信息。



## 用户管理命令

**用户和用户组**

创建用户时所在组称**初始组/主组**，其后可以将其添加到其他组中，这些组称**附加组**，此外，还可以更换用户的主组。

root 用户 uid 0

系统用户 uid 1 - 1000

普通用户 uid 1001+

用户和用户组的配置文件

- /etc/passwd
- /etc/group
  

创建用户/组

```shell
useradd <unm>
groupadd <gnm>
```

 修改用户/组

修改信息

```shell
usermod [-u | -d | -g] <unm> # uid 主目录 主组
groupmod [-n | -g | -o] <gnm> # 名称 gid 允许重复的gid
```

修改密码/管理用户组

```shell
passwd
gpasswd [-A | -a | -d] # 指定管理员 添加用户 删除用户
```

 删除用户/组

```shell
userdel <unm>
groupdel <gnm>
```

切换用户

```shell
su <unm>
```



`who` 查看登陆用户信息

1. 第一列 登陆用户名
2. 第二列 登陆终端 tty表示本地终端 pts表示远程登陆终端
3. 第三列 登陆时间
4. 第四列 登陆主机的IP地址 如果没有写表示本机登陆

`w` 查看登陆用户详细信息

- **第一行显示**
  17:04:55 up 22 days, 21:32, | 2 users,| load average: 0.02, 0.02, 0.05

  1. ``17:04:55 ``表示当前时间

  2. ` up 22 days, 21:32` 表示服务区系统连续运行时间没有重启或者关机，衡量服务区稳定性

  3.  ``2 users`` 表示当前总共有多少个用户登陆

  4. `load average: 0.02, 0.02, 0.05` 表示负载均衡指数，分别记录了过去一分钟，五分钟，十五分钟系统的负载情况，加起来除以三就是平均负载指数，系统的负载情况主要是指 CPU和内存的负载情况，数字大表示负载严重。

     > uptime 命令也可以显示此项数据

- **第二行显示**
  USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT
  
  1. ``IDLE ``表示用户登陆过来后空闲多久
  2. ``PCPU`` 表示用户登陆后执行的操作占用的CPU的时间 CPU时间
  3. ``JCPU ``表示累计占用的CPU时间
  4. ``WHAT ``表示执行的操作



 **who 命令**

```shell
# root
who am i
> username pts/0        2020-04-21 14:41 (:1.0)

# root
who mom likes
> username pts/0        2020-04-21 14:41 (:1.0)

# pre user
whoami
> username

# root
who -m
> username pts/0        2020-04-21 14:41 (:1.0)
```

`pts/{num}`中的`pts`表示伪终端，`{num}`表示用户打开的伪终端序号。

相对来说，`dev/tty`是真终端，`pts`是在某个真终端下的伪终端，可以存在多个。

| param | description           |
| :---- | :-------------------- |
| `-a`  | 打印能打印的全部      |
| `-d`  | 打印死掉的进程        |
| `-m`  | 同`am i`，`mom likes` |

---





## 文件打包

**打包和压缩的区别**
>
> - 打包  :  将多个文件和目录集中存储在一个文件中。
>
> - 压缩  :  利用算法对文件进行处理，从而达到缩减占用磁盘空间的目的。
>
> Linux下，常用打包命令有2个，分别是tar和dd;
>
> 常用的压缩命令有很多，比如gzip、zip、bzip2等。

**打包**

打包，也称为归档(archive)，指的是一个文件或目录的集合，而这个集合被存储在一个文件中。

> 归档文件没有经过压缩，因此，它占用的空间是其中所有文件和目录的总和。通常，归档总是会和系统备份联系在一起。

**压缩**

压缩是指利用算法将文件进行处理，已达到保留最大文件信息，而让文件体积变小的目的。

> 其基本原理为，通过查找文件内的重复字节，建立一个相同字节的词典文件，并用一个代码表示。

### 打包工具

####  tar打包

```shell
tar -cf {pack} {dir}
```

**必选参数：**

`-f` :使用档案名字，该参数作为最后一个参数，后面只能接档案名。

>-f   是执行tar过程中需要携带的

**可选参数：**

- `-p`，保留文件属性（权限等）。

- `-h`，追踪链接并归档。

- `-P`保留绝对路径符，即路径前的`/`。若保留，则解压时会按照绝对路径进行解压。

  > 解压时也可通过`-P`参数指定是否通过绝对路径解压。不过，对于根本就不是绝对路径的文件，不会按照绝对路径解压。

- `-c`: 建立压缩档案

- `-x`：解压（会根据压缩格式自动进行识别）

- `-t`：查看内容

- `-r`：向压缩归档文件末尾追加文件

- `-u`：更新原压缩包中的文件

> 这些选项作为 tar 使用过程中根据执行的操作进行选择，必须要有其一。

注意：默认尽可能地按照相对路径解压，防止意外覆盖文件。



 **tar解包：**

```shell
tar -xf {pack} -C {dir}
```

> `-x`表示解包`-C {dir}`指定解包目录。

- 可选参数`-P`保留绝对路径符，对于不是绝对路径的文件，不会按照绝对路径解压。

**tar使用压缩工具：**

压缩时只需要加上对应参数即可，例如`gzip`对应`-z`：

```shell
tar -zcf {pack} {dir}
```

解包时统样：

```shell
tar -zxf {pack}
```

| 压缩文件格式 | 参数 |
| :----------- | :--- |
| `*.tar.gz`   | `-z` |
| `*.tar.xz`   | `-J` |
| `*tar.bz2`   | `-j` |



### 压缩工具

下面为压缩或解压档案时的可选参数。

- `-z`：有 gzip 属性的压缩及解压

- `-j`：有 bz2 属性的压缩及解压

- `-Z`：有compress属性的压缩及解压

- `-v`：显示所有打包及压缩解压过程

- `-O`：将文件解开到标准输出

#### zip 压缩

 **zip打包：**

```shell
zip -r -q -9 -o {pack} {dir}
```

> `-r`表示递归打包子目录，`-q`是静默打包，不输出信息，`-9`是压缩质量，最高 9 最低 1，`-o`后紧跟输出的文件。

另外还可以加一个参数`-e`进行加密打包。

对于跨平台的换行问题，可以通过`-l`参数在打包的同时进行转换，将`LF`转换为`CRLF`。

**unzip解包：**

```shell
unzip -q {pack}
```

可以使用`-d {dir}`指定解压目录：`unzip -q {pack} -d {dir}`。

`-O`可以指定编码，例如`-O GBK`。

`unzip`可以用来查看压缩包信息，通过`-l`参数：`unzip -l {pack}`。



#### gzip压缩

- **gzip打包**

gzip [文件名] 压缩文件 只能压缩文件不能压缩目录，而且不保留原文件

> 压缩后格式为：.gz



- **gzip解包**

gunzip [压缩包名] 解压缩.gz文件

gzip -d [压缩包名] 也是一样的作用，解压缩.gz文件



#### bzip压缩

**bzip 打包:**

```shell
bzip2 [选项] [文件名] 压缩文件
```

**大型文件一般用这个压缩**

> 例子：
> bzip2 -k Japan

- -k：保留原文件。如果不需保留可去掉。
  
- 可以与tar结合使用

  > tar -cjfv Japan.tar.bz2 Japan

**Bunzip 解包:**

```shell
bunzip2 [选项] [压缩文件名] 解压文件
```

- -k：保留压缩包

- 与tar结合使用 :

  > tar -xjfv Japan.tar.bz2 Japan



## 关机命令

**关机/重启**

```shell
shutdown [-r | -h] <time>   #shutdown [选项] 时间

shutdown -r now # 重启
reboot

shutdown -h now # 关机
poweroff


#时间选项里可以填具体时间比如：
#now 现在关机
#20:30 八点半关机

shutdown -r +5 # 5min
shutdown -h +5 # 5min

shutdown -r 5:00 # 5:00
shutdown -h 5:00 # 5:00
```

- -c：取消前一个关机命令
- -h：关机
- -r：重启

> 在服务器上重启需要谨慎，需要先停掉服务，否则物理内存会坏
> 而且远程服务器只能重启，关机后需要管理员手动开机

**其他关机命令：**

- halt
- poweroff 相当于直接断电
- init 0

> 推荐使用shutdown关机，会保存正在运行的服务

**其他重启命令：**
reboot



## 挂载命令

如果想要访问Linux中的根目录以外的文件，需要将它“关联”到根目录下的某一个目录来实现，这种关联操作就叫做“挂载”，这个目录就是“挂载点”，解除次关联关系的过程就是“卸载”。



“挂载点”的目录有3个要求：

（1）可以用mkdir命令新建目录（目录事先存在）。

（2）挂载点目录不可被其他进程使用到。

（3）挂载点下原有文件被隐藏。



> 知乎：挂载可以理解为插乐高积木（我闺女最近很爱玩这个；），首先系统一定要先有一个根文件系统并挂载在"/"上，你可以理解为你用乐高做了一个机器人，在系统启动后这就是根文件系统了。之后你想再挂载新文件系统，就好像你又用乐高插出一把剑（一个新的独立文件系统），你可以把剑插在机器人任何能插的地方，比如右手上。剑是独立的，你改变剑的形状并不影响机器人本身，将来你不想用这把剑了可以直接拆下来（卸载）收好，也可以再插（挂载）一把枪（另一个文件系统）上去。
>
> 文件系统挂载时有覆盖（/遮盖）关系，如果你所要挂载的挂载点（/目录）下面有文件或已挂载的文件系统，那么新挂载的文件系统会遮盖其下面的内容。这点和乐高不同，比如你又做了一个新的机器人右手臂，你得自己把原右手臂连同手上的东西拆下来，再插上新作的。而实际的文件系统挂载不需要先卸载，新文件系统（右手臂）会直接从挂载点（右臂接口）开始覆盖（/隐藏）挂载点（接口）以下所有的原内容。而卸载后原内容又会显现出来。
>
> 来自用户：醉卧沙场

```shell
mount [-t 文件系统] 设备文件名 挂载点
```

mount 设备文件名/挂载点 卸载光盘，设备文件名和挂载点两者任选其一

1. 放入光盘 :  虚拟机中放入，或者服务器下载ios文件

2. 创建一个空目录，设为挂载点
   
   ```shell
   mkdir /media/cdrom /media 
   ```
   
3. 输入命令
   ```shell 
   mount -t iso9660 /dev/sr0 /media/cdrom
   ```
   设备文件名默认就是/dev/sr0，文件系统为iso9660 它是国际标准的cd文件格式，它告诉mount命令，我要挂载的是一个标准的cd。需要死记！！！
   
   > /dev/cdrom也可以写 /dev/sr0
   > /dev/cdrom是sr0的软链接。
   
4. 进入挂载后的盘符
   
   ```shell
   cd /media/cdrom
   ```
   
5. 卸载光盘
   
   ```shell
   cd  #先退出/media/cdrom
   umount /dev/sr0  #再输入命令：umount /dev/sr0
   ```
   
   > 注意：如果之前挂载过其他盘，需要卸载之后才能挂载，输入命令：
   >
   > `umount /dev/sr0`
   
   

### 网络命令

给在线用户发信息

```shell
write <用户名>
```

按Ctrl+D保存结束 只能给在线用户发 可以用w查询用户在线情况 不在线发不出去。

```shell
wall [信息] 发广播信息 
```

群发所有在线用户

- `ping [IP地址] 测试网络连通性`

- `ping -c` 指定发送次数

- `ifconfig` 查看网卡信息

  > 主要功能是查询当前本机IP地址

- `mail <用户名>`给不在线的用户发送邮件

  ```shell
  mail <friend_name>
  
  Subject <headline> #输入标题
  <content>#正文
  #Ctrl D 保存结束发送
  
  ```

  



- `h` 键查看邮箱列表
- `d [n]` 删除第n封邮件
- `q` 退出



- last 列出目前与过去登陆系统的用户信息

- lastlog 检查某特定用户上次登陆的时间

- lastlog -u [uID] 检查uID用户上次登陆的时间

- traceroute 显示数据包到主机间的路径
  这里CentOS7用户也会出现traceroute命令不能使用的问题，直接下载traceroute就好了
  yum install -y traceroute 安装

- traceroute [网站网址] 可以检查网络哪个节点出现问题

- netstat [选项] 显示网络相关信息

  1. -t TCP协议：传输控制协议
  2. -u UDP协议：用户数据报
  3. -l 监听
  4. -r 路由：网关
  5. -n 显示IP地址和端口号

- netstat -tlun ：查询本机监听的端口

- netstat -an ：查看本机所有的网络连接

- netstat -rn ：查看本机路由（网关）

- setup 配置网络 （redhat专有命令 ,在其他版本不存在）

  > 永久生效 , 和刚开始介绍的ifconfig命令不一样。
  > CentOS7使用 nmtui命令代替setup，不过是在虚拟机中调试