# 三种变量

在 Linux 中，变量依照作用域分为三种，分别是**环境变量**、**普通变量**、**导出变量**。

- **环境变量**可以理解为 Windows 中的环境变量，在任一终端总可以直接访问到。

公共变量被存放在`/etc/profile`文件中，用户变量被存放在`~/.profile`中。

```shell
cat /etc/profile
```

- **普通变量**仅在当前进程可用，在子进程中无法访问。

可以通过`declare {var}`声明变量或使用`{var}={value}`直接定义。通过`echo ${var}`查看变量。通过`unset {var}`释放变量。

```shell
declare temp
temp=333
echo $temp
unset temp
```

- **导出变量**是临时环境变量，即临时导出到环境变量的普通变量。可以通过`export {var}`对普通变量进行导出，**此时其子进程也可以访问该变量。**

当前进程结束时，该导出变量一并销毁。

```shell
export temp
```

有三个命令可以查看变量：

```shell
set    # 显示所有变量
env    # 显示用户相关的环境变量
export # 显示导出变量

export 变量名=变量值 #申明变量

env# 查询变量

echo $变量名# 变量调用

unset 变量名 #删除变量

pstree 树形显示进程数
#没有这条命令可以执行以下命令下载：
#yum -y install psmisc
#yum provides /命令 查看没有的命令的安装包 配合yum -y install使用

```

# 环境变量

定义阐述：环境变量配置文件中，主要是**定义对系统的操作环境生效的系统默认环境变量**，比如 PATH、HISTSIZE、PS1、HOSTNAME等 默认环境变量。 

**以下几个环境变量的配置文件是最主要的：**

- /etc/profile
- /etc/profile.d/\*.sh  (指/etc/profile.d/下所有的.sh结尾的文件)
- ~/.bash_profile
- ~/.bashrc
- /etc/bashrc

**环境变量配置文件调用图：**

 ![img](https://img-blog.csdnimg.cn/20200525190315737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l5MTUwMTIy,size_16,color_FFFFFF,t_70#pic_center) 

> 这些是在登陆的时候挨个调用，所以在这里面设置环境变量，登陆之后就会自动设置好
>
> - 登陆输入密码之后，第一步是读取/etc/profile文件
>   **/etc/profile的作用：**
>   USER变量
>   LOGNAME变量
>   MAIL变量
>   PATH变量
>   HOSTNAME变量
>   HISTSIZE变量
>   umask
>   **里面有以上环境变量的配置**
>
> - **接下来便调用/etc/profile.d/* .sh文件**
>   然后就是下面的文件，语言包文件，识别系统自带的语言
>
> - ***~/.bash_profile的作用**
>   调用了~/.bashrc文件。
>   在PATH变量后面加入了“:$HOME/bin” 这个目录~/.bashrc的作用
>   定义默认别名调用/etc/bashrc
>
> - **/etc/bashrc的作用**
>   PS1变量
>   umask
>   PATH变量
>
> - **调用/etc/profile.d/*.sh文件**
>   这一块就是进入界面以内，切换shell登陆方式，这种不需要密码，所以和前面的/etc/profile的作用不冲突
>
>   

# 变量操作

**变量添加：**

以`PATH`为例，将某路径添加到`PATH`环境变量中。

由于`PATH`变量以`:`作为分隔符，所以我们应该将`:{dir}`追加到`PATH`的末尾。

```shell
PATH=$PATH:/home/user/dir
```

字符串拼接不需要使用`+`，直接顺着写即可。

注意！！这种方式添加的环境变量是临时的，当关闭终端时失效。

想要让环境变量一直生效，可以让上述命令在终端初始化时执行，**终端在初始化时会调用一个脚本**，这里使用的是`zsh`，所以这个脚本位于用户主目录下`~/.zshrc`。

我们可以编辑他，将这条命令添加进去。

```shell
echo "PATH=$PATH:/home/user/dir" >> .zshrc
```

不过对于不同终端，这个初始化脚本也不同，例如`bash`的初始化脚本是`.bashrc`。

可以通过`cat /etc/shells`查看已安装的`Shell`

```shell
cat /etc/shells
```

**介绍一个命令`echo`：**

```shell
echo {string}
```

`echo`可以将字符串输出到终端，如果要输出变量，那么变量名前应添加一个`$`。

`echo`还可以将输出定向至文件：

```shell
echo {string} > {filename}
echo {string} >> {filename}
```

`>`是直接覆盖文件，`>>`是追加到文件。

**变量修改**

| 变量修改方式                   | 说明                                         |
| :----------------------------- | :------------------------------------------- |
| `${变量名#匹配字串}`           | 从头向后开始匹配，删除符合匹配字串的最短数据 |
| `${变量名##匹配字串}`          | 从头向后开始匹配，删除符合匹配字串的最长数据 |
| `${变量名%匹配字串}`           | 从尾向前开始匹配，删除符合匹配字串的最短数据 |
| `${变量名%%匹配字串}`          | 从尾向前开始匹配，删除符合匹配字串的最长数据 |
| `${变量名/旧的字串/新的字串}`  | 将符合旧字串的第一个字串替换为新的字串       |
| `${变量名//旧的字串/新的字串}` | 将符合旧字串的全部字串替换为新的字串         |

例如，我想将`PATH`变量中的`:/home/user/dir`删除：

```shell
PATH={PATH%%:/home/user/dir}
```

**执行初始化脚本**

更改配置文件后，如果想要立即生效，就要重新执行一遍该脚本。

我们可以使用`source`命令：

```shell
source ./.zshrc
```

或者直接简写为：

```Shell
. ./zshrc
```

# 变量设置规则

**变量设置规则：**

- 变量名称可以由字母、数字和下划线组成 ，但是不能以数字开头。如果变量名是 “2name”则是错误的。
- 在Bash中，变量的默认类型都是字符串型 ，如果要进行数值运算，则必需指定变量类型为数值型。
- 默认变量类型全都是字符串型，和其他语言不太一样。
- 变量用等号连接值，等号左右两侧不能有空格。
- 变量的值如果有空格，需要使用单引号或双引号包括。
- 在变量的值中，可以使用“\”转义符。
- 如果需要增加变量的值，那么可以进行变量值的叠加。不过变量需要用双引号包含 “$变量名”或用${变量名}包含。
- 如果是把命令的结果作为变量值赋予变量 ，则需要使用反引号或$()包含命令。
- 环境变量名建议大写，便于区分。

**变量的分类：**

- 用户自定义变量
- 环境变量:这种变量中主要保存的是和系统操作环境相关的数据。
- 位置参数变量:这种变量主要是用来向脚本当 中传递参数或数据的，变量名不能自定义，变量作用是固定的。
- 预定义变量:是Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定的。





# 变量划分

## 系统常见环境变量

系统常见环境变量

- PATH:系统查找命令的路径
  这便是输入命令之前不用输入绝对路径的根本原因，系统会提前在PATH环境变量里的所有路径中查询一遍有没有你输入的命令，找到之后直接执行。

  如果你想直接执行shell脚本，不加绝对路径，直接写入PATH环境变量，使用叠加。

  > 例子：
  >
  > ```shell
  > echo $PATH
  > PATH="$PATH":/root/sh #PATH变量叠加
  > ```
  >
  > 此后，/root/sh路径里面的执行文件都可以在任意目录下直接执行，不过是临时生效

- PS1：定义系统提示符的变量 用来改[root@localhost ~]# 这个显示

  **下面是系统提示符的变量：**

  - \d:显示日期，格式为“星期 月 日”
  - \h:显示简写主机名。如默认主机名“localhost”
  - \t:显示24小时制时间，格式为“HH:MM:SS”
  - \T:显示12小时制时间，格式为“HH:MM:SS”
  - \A:显示24小时制时间，格式为“HH:MM”
  - \u:显示当前用户名
  - \w:显示当前所在目录的完整名称
  - \W:显示当前所在目录的最后一个目录
  - #:执行的第几个命令
  - $:提示符。如果是root用户会显示提示符为“#”，如果是普通用户 会显示提示符为“$”

## 位置参数变量

在脚本中主要针对参数的一些变量操作。

| 位置参数 变量 | 作用                                                         |
| ------------- | ------------------------------------------------------------ |
| $n            | n为数字，$0代表命令本身，$1-9 代 表 第 一 到 第 九 个 参 数 ， 十 以 上 的 参 数 需 要 用 大 括 号 包 含 ， 如 9代表第一 到第九个参数，十以上的参数需要用大括号 包含，如9代表第一到第九个参数，十以上的参数需要用大括号包含，如{10}. |
| $*            | 这个变量代表命令行中所有的参数，$*把所 有的参数看成一个整体  |
| $@            | 这个变量也代表命令行中所有的参数，不过 $@把每个参数区分对待  |
| $#            | 这个变量代表命令行中所有参数的个数                           |

举例：

```bash
#$n的例子:一个加法器
num1=$1
num2=$2
sum=$(( $num1 + $num2)) #变量sum的和是num1加num2 echo $sum #打印变量sum的值
echo $sum
```

## 预定义变量

| 预定义变量 | 作用                                                         |
| ---------- | ------------------------------------------------------------ |
| $?         | 最后一次执行的命令的返回状态。如果这个变 量的值为0，证明上一个命令正确执行;如果 这个变量的值为非0(具体是哪个数，由命令 自己来决定)，则证明上一个命令执行不正确 了。 |
| $$         | 当前进程的进程号(PID)                                        |
| $!         | 后台运行的最后一个进程的进程号(PID)                          |

```shell
echo “The current process is $$”
#输出当前进程的PID。
#这个PID就是variable.sh这个脚本执行时，生成的进程的PID
find /root -name hello.sh &
#使用find命令在root目录下查找hello.sh文件 #符号&的意思是把命令放入后台执行，工作管理在系统管理章节会详细介绍
echo "The last one Daemon process is $!"
```

**接受键盘输入**

```shell
read [选项] [变量名]
```

- -p “提示信息”:在等待read输入时，输出提示信息
- -t 秒数: read命令会一直等待用户输入，使用 此选项可以指定等待时间
- -n 字符数:read命令只接受指定的字符数，就会执行
- -s: 隐藏输入的数据，适用于机密信息的输入





## 其他配置文件和登录信息

**注销时生效的环境变量配置文件**

- ~/.bash_logout
  注销登陆时写入

**其他配置文件**

- ~/bash_history 历史命令文件

**Shell登录信息**

- 本地终端欢迎信息: /etc/issue

  | 转义符 | 作用                             |
  | ------ | -------------------------------- |
  | \d     | 显示当前系统日期                 |
  | \s     | 显示操作系统名称                 |
  | \l     | 显示登录的终端号，这个比较常用。 |
  | \m     | 显示硬件体系结构，如i386、i686等 |
  | \n     | 显示主机名                       |
  | \o     | 显示域名                         |
  | \r     | 显示内核版本                     |
  | \t     | 显示当前系统时间                 |
  | \u     | 显示当前登录用户的序列号         |

- **远程终端欢迎信息:`/etc/issue.net`**
  - 转义符在/etc/issue.net文件中不能使用。
  - 是否显示此欢迎信息，由ssh的配置文件` /etc/ssh/sshd_config`决定，加入“Banner /etc/issue.net”行才能显示(记得重启SSH服务)。
- 登陆后欢迎信息:`/etc/motd`
  不管是本地登录，还是远程登录，都可以显示此欢迎信息。









# 变量运算

**declare 声明变量类型**

```shell
declare [+/-][选项] 变量名
```

- -: 给变量设定类型属性
- +: 取消变量的类型属性
- -i: 将变量声明为整数型(integer) set-x: 将变量声明为环境变量
- -p: 显示指定变量的被声明的类型

**数值运算**

1. 数值运算

```shell
aa=11
bb=22 #给变量aa和bb赋值
declare -i cc=$aa+$bb
```

2. expr或let数值运算工具

```shell
aa=11
bb=22 #给变量aa和bb赋值
dd=$(expr $aa + $bb)# dd的值是aa和bb的和。注意“+”号左右两 侧必须有空格
```

> let与expr一样。

3. “$((运算式))”或“$[运算式]”

```shell
aa=11
bb=22 给变量aa和bb赋值
ff=$(( $aa+$bb ))
gg=$[ $aa+$bb ]
```





优先级表：



> 优先级	运算符	说明
> 13	-, +	单目负、单目正
> 12	!, ~	逻辑非、按位取反或补码
> 11	*,/, %	乘、除、取模
> 10	+, -	加、减
> 9	<< , >>	按位左移、按位右移
> 8	< =, > =, < , >	小于或等于、大于或等于、小于、大于
> 7	== , !=	等于、不等于
> 6	&	按位与
> 5	^	按位异或
> 4	|	按位或
> 3	&&	逻辑与
> 2	||	逻辑或
> 1	=,+=,-=,*=,/=,%=,&=, ^=,赋值、运算且赋值 |=, <<=, >>=	

## 变量测试与替换

用来测试一个变量到底有没有设置，测试表：

变变量置换方式	变量y没有设置	变量y为空值	变量y设置值
x=${y-新值}	x=新值	x为空	x=$y
x=${y:-新值}	x=新值	x=新值 x=$y	
x=${y+新值}	x为空	x=新值	x=新值
x=${y:+新值}	x为空	x为空	x=新值
x=${y=新值}	x=新值 y=新值	x为空 y值不变	x=$y y值不变
x=${y:=新值}	x=新值 y=新值	x=新值 y=新值	x=$y y值不变
x=${y?新值}	新值输出到标准错误输出(就是屏幕)	x为空	x=$y
x=${y:?新值}	新值输出到标准错误输出	新值输出到标准错误输	x=$y

**例子：**
测试x=${y-新值} 测试y变量存不存在

- ```shell
  unset y 删除变量y
  x=${y-new} 进行测试
  echo $x
  ```
  显示new，y变量不存在
  因为变量y不存在，所以x=new
  
- ```shell
  y="" 给变量y赋值为空
  x=${y-new} 进行测试
  echo $x
  ```
  显示空，y为空值
  
- ```shell
  y=old 给变量y赋值
  x=${y-new} 进行测试
  echo $x
  ```
  显示old ，y变量存在且有值
  
  **在用到的时候查询就好，不需要死记硬背。这个表是在写脚本的时候给电脑程序看的，人不参与其中**