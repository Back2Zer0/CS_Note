# 继承和多态

## 概念

#### 继承

- 继承`extends`：Java 中的继承均为公有继承
- 子类和超类：即子类和父类（也称基类）

Java 的继承不用考虑诸如虚函数（虚表、虚指针）等底层细节，不需要额外的显式声明就可以实现动态多态。

也就是说，Java 的方法均为虚函数（并不严谨），如果不希望让一个方法是虚拟的，可以使用`final`关键字修饰。或者，对于`static`、`private`方法，不涉及动态多态。

> 虚表、虚指针是 C/C++ 对多态的实现方案，Java 有自己的实现方案 --> 方法表。
>
> 不过从思路上讲，基本上是差不多的。

与 C/C++ 不同，Java 不允许**多重继承(multiple inheritance)**，即一个类拥有多个父类，但允许**多层继承(multi level inheritance)**。

多重继承有一定的好处，但会带来相当的复杂性和性能开销，于是 Java 采用了一个被称为"接口"的概念来获得多重继承的大多数好处，同时也规避了一些设计复杂性。接口将在后面的部分讨论。

```java
class Son extends Father {
    // ...
}
```

#### 多态

- 多态的抽象表述：**==接口与实现的分离==**。
- 具体一些可以称：**==父类指针（引用）指向子类对象==**。

> 为了访问安全性，Java 不允许父类对象（实际上的）向下转型。会抛出`ClassCastException`异常。

## 访问权限

涉及到继承，就一定要谈`protected`权限修饰符。

一般情况下，我们希望隐藏域，开放方法，让开发者依赖接口而非实现，但`private`的域是被完全隐藏的，即便是子类都无法访问。

但有时候我们希望子类能访问一些私有域（或私有方法），就需要使用`protected`来代替`private`修饰成员，子类将可以访问到该成员（但是访问不到其他实例的`protected`成员）。

再放一次这个表，加深理解：

| 修饰符    | 访问范围             |
| :-------- | :------------------- |
| public    | 均可访问             |
| protected | 包内和所有子类可访问 |
| （缺省）  | 包内可访问           |
| private   | 仅本类访问           |

## 访问父类`super`

由于子类不能直接访问父类的私有域，所以我们应该调用父类的构造。

在子类构造的开头，Java 为我们隐式调用了父类的默认构造`super()`，但当不存在默认构造时，我们需要手动调用`super()`，且必须为第一个语句：

```java
class Son extends Father {
    public Son (int param) {
        super(param); // 手动调 super
        // ...
    }
}
```

`super`还可以访问到所有父类允许访问的 constructor、method 及 field：

```java
class Son extends Father {
    public void method() {
        super.field;
        super.method();
        // ...
    }
}
```

不过，尽管这种方法令`super`很像一个对象的引用（类似`this`），但并非如此，`super`仅仅是一个指示调用父类的关键字。

> 在 C/C++ 中，我们使用`父类::成员`的形式引用父类的内容。

另外地，也可以通过`this`调用本类构造（委托构造）：

用于为构造函数提供默认值（Java 中没有默认参数）。

```java
class Type {
    public Type() {
        this(10);
    }
    public Type (int param) {
        // ...
    }
}
```

## 重写

重写父类方法，实现动态多态。也叫（覆盖，覆写）

!!! 注意：

- 为防止寻址超出范围，子类方法的返回值，若改变，则仅可为父类方法返回类型的子类，这被称为"协变返回类型"。

  C++ 允许这样做，但不保证安全，所以 Java 禁止了。

- **子类方法不能低于父类方法的可见性**，例如子类无法用`private`修饰符重写一个父类的`public`方法。这会导致发生多态时的访问权限冲突。

  C++ 同样允许这样做，但当试图访问不可访问的方法时，编译出错。

  Java 允许的是可见性较大的重写为可见性较小的，具体表现为：

  `public` > `protected` > `(默认)` > `private`

  还要注意的是，父类的 private 方法无法被重写。在子类写同名方法不会出错，但这不是重写，而是一个新方法。



```java
class Father {
    public void method() {
        // ...
    }
}
class Son extends Father {
    public void method() {
        // ...
    }
}
```

推荐使用注解：

`@override`用于检测是否发生了正确的重写，是一种安全检测手段。

注解后若未正确重写会出现编译错误。

```java
class Son extends Father {
    @override
    public void method() {
        // ...
    }
}
```

**注解（Annotation）**

 作用在代码的注解：

- `@Override` - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。
- `@Deprecated` - 标记过时方法。如果使用该方法，会报编译警告。
- `@SuppressWarnings` - 指示编译器去忽略注解中声明的警告。

作用在其他注解的注解(或者说 元注解):

- `@Retention` - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。
- `@Documented` - 标记这些注解是否包含在用户文档中。
- `@Target` - 标记这个注解应该是哪种 Java 成员。
- `@Inherited` - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)

从 Java 7 开始，额外添加了 3 个注解:

- `@SafeVarargs` - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。
- `@FunctionalInterface` - Java 8 开始支持，标识一个匿名函数或函数式接口。
- `@Repeatable` - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。

## 多态抑制

如果不希望一个方法被子类重写，可以使用`final`修饰该方法：

```java
final public int method() {
    // ...
}
```

> 对于 private 方法，可以使用`final`修饰，但没什么用，因为子类根本无法重写它。

如果不想让某个类可以被继承，使用`final`修饰该类：

```java
final class Type {
    // ...
}
```

可以将`final`看作一个多态的抑制关键字，在 Java 中，如果不希望一个类（对象）展现出多态性，就要显式声明它为`final`。换言之，**任何未显式声明的 Java 类都具有多态性**。

这与 C/C++ 的设计哲学不同，在 C/C++ 中，**任何类都不具备多态性**（这与 C/C++ 的对象内存结构有关），除非我们显式声明它（虚函数）。